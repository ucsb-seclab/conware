#!/usr/bin/env python
# Native
import argparse
import os
from time import sleep
import importlib
from avatar2 import *
from avatar2.targets.jlink_target import JLinkTarget
import logging
import pickle

import pretender
from pretender.bin_parser import M3Parser
from pretender.logger import LogWriter
from pretender.coverage import get_hit_blocks
from pretender.common import *

logger = logging.getLogger(__name__)

# A few globals
seq = 0
memory_log = None
time_start = None
compare_model = None


def record_read_after(avatar, message, **kwargs):
    """
        Record any reads that were forwarded to the hardware

        see avatar.ui.message.py

    :param avatar:
    :param message:
    :param kwargs:
    :return:
    """
    global seq, memory_log, time_start, compare_model
    _, val, success = kwargs['watched_return']

    model_val = ""
    model_name = ""
    if compare_model is not None:
        # IMPORTANT: This must be done before the actual read, because the read
        # can influence the model!
        model_name = compare_model.get_model(message.address)

        # Read the value
        model_val = compare_model.read_memory(message.address, message.size)

    if not message.dst or 'model' in message.dst.name:
        logger.debug(
            "IGNR:  %s (%s, %s) @ %s" % (message, hex(message.address), val,
                                         hex(message.pc)))
    else:
        logger.debug(
            "READ:  %s (%s, %s, %s) @ %s" % (message, hex(message.address),
                                             val, model_val, hex(message.pc)))
        memory_log.write_row(
            ['READ', seq, message.address, val, model_val, message.pc,
             message.size, time.time() - time_start, model_name])
        # pprint.pprint(kwargs)
        seq += 1


def record_write_after(avatar, message, **kwargs):
    """
        Record any writes that were forwarded to the hardware

        see avatar.ui.message.py

    :param avatar:
    :param message:
    :param kwargs:
    :return:
    """
    global seq, memory_log, time_start, compare_model
    _, val, success = kwargs['watched_return']

    model_val = ""
    model_name = ""
    if compare_model is not None:
        # IMPORTANT: This must be done before the actual write, because the
        # write can influence the model!
        model_name = compare_model.get_model(message.address)

        # Write to our model
        compare_model.write_memory(message.address, message.size,
                                   message.value)

    if not message.dst or "model" in message.dst.name:
        logger.debug("IGNW %s (%s,%s) @ %s" % (message, hex(message.address),
                                               message.value, hex(message.pc)))
    else:
        logger.debug("WRITE %s (%s,%s,%s) @ %s " % (message,
                                                    hex(message.address),
                                                    message.value,
                                                    model_val, hex(message.pc)))
        memory_log.write_row(
            ['WRITE', seq, message.address, message.value, model_val,
             message.pc, message.size, time.time() - time_start, model_name])
        # pprint.pprint(kwargs)
        seq += 1


def record_interrupt_enter(avatar, message, **kwargs):
    """
        Record any interrupts that were forwarded from the hardware

        see avatar.ui.message.py

    :param avatar:
    :param message:
    :param kwargs:
    :return:
    """
    global seq, memory_log, time_start, compare_model
    # message.origin.wait()
    # isr = message.origin.protocols.interrupts.get_current_isr_num()
    isr = message.interrupt_num
    # TODO: Fill this out with something more intelligent
    memory_log.write_row(['ENTER', seq, isr, 0, 0, 0, time.time() - time_start])
    logger.warning \
        ("ENTER %s %s" % (hex(isr), message))
    seq += 1


def record_interrupt_exit(avatar, message, **kwargs):
    """
        Record any interrupt exits that were forwarded from the hardware

        see avatar.ui.message.py

    :param avatar:
    :param message:
    :param kwargs:
    :return:
    """
    global seq, memory_log, time_start, compare_model
    # TODO: Fill this out with something more intelligent

    isr = message.interrupt_num
    memory_log.write_row(['EXIT', seq, isr, 0, 0, 0, time.time() - time_start])
    logger.warning("EXIT %s %s" % (hex(isr), message))
    seq += 1


def record_interrupt_return(avatar, message, **kwargs):
    """
        Record any interrupt returns that were forwarded forwarded the hardware

        see avatar.ui.message.py

    :param avatar:
    :param message:
    :param kwargs:
    :return:
    """
    global seq, memory_log, time_start, compare_model
    # TODO: Actually make this work, return is different from exit
    # TODO: Fill this out with something more intelligent
    memory_log.write_row(
        ['EXIT', message.id, isr, 0, 0, 0, time.time() - time_start])
    logger.debug("RETURN %s %s" % (hex(isr), message))


def parse_args():
    """
    Parse our arguments and do the proper checks

    Note:  Some variables are set dynamically (e.g., args.model_file)
    :return:
    """
    global compare_model
    # Default argument values
    default_sample = "bins/Nucleo_blink_led.bin"
    openocd_conf = '/usr/share/openocd/scripts/board/st_nucleo_l1.cfg'
    output_dir = 'recording'
    qemu_executable = os.path.join(os.path.dirname(__file__),
                                   "../../avatar2-pretender/targets/build/qemu" \
                                   "/arm-softmmu/qemu-system-arm")
    gdb_port = 1235
    qemu_port = 23454

    # Get user input
    parser = argparse.ArgumentParser()
    parser.add_argument("--sample", "-s", default=default_sample,
                        help="Binary being analyzed.")
    parser.add_argument("--board-config", help="Board config file YAML")
    parser.add_argument("--openocd_conf", "-c", default=openocd_conf,
                        help="OpenOCD config file.")
    parser.add_argument("--output_dir", "-o", default=output_dir,
                        help="Output directory for logging.")
    parser.add_argument("--gdb_port", "-g", default=gdb_port,
                        help="GDB port number.")
    parser.add_argument("--qemu_executable", "-x", default=qemu_executable,
                        help="QEMU Executable.")
    parser.add_argument("--qemu_port", "-q", default=qemu_port,
                        help="QEMU Port.")
    parser.add_argument("--debug", "-d", default=False, action='store_true',
                        help="Enable debug output.")
    parser.add_argument('--proto', help="Select Avatar protocol to use",
                        choices=('openocd', 'gdb', 'jlink'), default='openocd')
    parser.add_argument('--coverage', '-C', default=False, action='store_true',
                        help="Generate QEMU block coverage info")
    parser.add_argument('--interrupts', '-I', action='store_true',
                        help="Enable interrupt recording mode via stub injection")
    parser.add_argument('--board', '-b', default=0,
                        type=int,
                        help="Which board # to reset on the YKUSH.  Defaults to 0 (don't reset the board")
    parser.add_argument('--partial-model', '-P', dest='partial_model',
                        help="Enable partial modeling with the selected modelogger.  Will find the sub-models that look cool, and use those instead of forwarding")
    # parser.add_argument("--logfile", "-l", default="memory.log",
    #                     help="Input log of memory accesses.")
    parser.add_argument('--stimulator', '-S',
                        help="Program to run to stimulate the target")
    parser.add_argument("--runs", "-r", default=1, type=int,
                        help="Number of times to run and record the firmware.")
    parser.add_argument("--sleep_time", "-t", type=float, default=120.0,
                        help="Time to sleep before killing Avatar. [default: "
                             "120 s]")
    parser.add_argument("--quiet", "-Q", action='store_true',
                        help="Quiet mode.")
    parser.add_argument('--shell', help="Drop to ipython shell",
                        action='store_true')
    parser.add_argument('--vomit', "-V", action='store_true',
                        help="Enable the vomit log from QEMU")
    parser.add_argument("--compare-model", "-X", action='store_true',
                        help="Will load an existing model and compare it to a live recording")
    parser.add_argument('--ivt_address', dest='ivt_address',
                        type=auto_int, default=None,
                        help="Address of IVT")
    parser.add_argument("--system_clock_scale", type=int, default=25,
                        help="Set the system clock scale")

    # Parse our arguments
    args = parser.parse_args()

    # Binary exist?
    args.sample = os.path.abspath(args.sample)
    if not os.path.exists(args.sample):
        logger.error("Sample file (%s) does not exist." % args.sample)
        sys.exit()
    # Qemu executable exist?
    if not os.path.exists(args.qemu_executable):
        logger.error("QEMU executable (%s) does not exist." %
                     args.qemu_executable)
        sys.exit()

    # Recording dir exist?
    if not os.path.exists(args.output_dir):
        logger.error("Output directory does not exist (%s)." %
                     args.output_dir)
        parser.print_help()
        sys.exit()
    # Are we comparing to a model that exists?
    if args.compare_model:
        model_file = os.path.join(args.output_dir, G.MODEL_FILE)
        if not os.path.exists(model_file):
            l.error("No model file found (%s).  Make sure you "
                    "trained a model!" % model_file)
            parser.print_help()
            sys.exit()
        # Load our model
        logger.info("Loading model from output directory...")
        compare_model = PretenderModel(filename=model_file)

    return args


def set_record_hooks(avatar, args):
    """
    Hook the memory regions and interrupts appropriately

    :param avatar:
    :param args:
    :return:
    """
    global memory_log
    # Reset our sequence number
    pretender.hooks.seq = 0

    # Get QEMU instance
    qemu = avatar.get_target('qemu')
    hardware = None
    try:
        hardware = avatar.get_target('hardware')
    except:
        logger.exception("No hardware detected.")

    # Monitor memory reads to forwarded MMIO
    logger.info("Adding watchmen for memory regions...")
    avatar.watchmen.add_watchman('RemoteMemoryWrite', 'after',
                                 record_write_after)
    avatar.watchmen.add_watchman('RemoteMemoryRead', 'after',
                                 record_read_after)

    # Are we recording interrupts?
    if args.interrupts:
        logger.info("Adding watchmen for interrupts...")
        avatar.watchmen.add_watchman('RemoteInterruptEnter', 'after',
                                     record_interrupt_enter)
        avatar.watchmen.add_watchman('RemoteInterruptExit', 'after',
                                     record_interrupt_exit)
        # import IPython; IPython.embed()
        rom = filter(lambda x: x.name == 'rom', [r.data for r in
                                                 avatar.memory_ranges])[0]
        avatar.forward_instructions(qemu, hardware, rom)


if __name__ == "__main__":
    args = parse_args()

    # Load arguments from the board configuration file
    args = load_config(args)

    # Setup Logging
    if args.debug:
        logging.basicConfig(level=logging.DEBUG)
        logging.getLogger().setLevel(logging.DEBUG)
        logger.setLevel(logging.DEBUG)
    elif args.quiet:
        logging.basicConfig(level=logging.WARNING)
        logging.getLogger().setLevel(logging.WARNING)
        logger.setLevel(logging.WARNING)
    else:
        logging.basicConfig(level=logging.INFO)
        logger.setLevel(logging.INFO)

    # Setup our binary parser
    # TODO: abstract this!
    bin_parser = M3Parser(args.sample)
    # Set our program counter
    ep = bin_parser.get_entry_point()
    sp = bin_parser.get_initial_sp()

    # Run the firmware the requested number of times
    simulator_proccess = None
    for run in range(args.runs):

        # Are we using a kushboard?
        if args.board:
            logger.warning("Resetting board %d" % args.board)
            reset_board(args.board)

        # Build our avatar object
        avatar = build_avatar(args)
        # Init qemu with our args
        qemu = build_qemu_emulator(avatar, args)
        # Init hardware with our logs
        hardware = build_hardware(avatar, args)
        # Setup which memory addresses should be forwarded to the hardware
        set_memory_map(avatar, args, model=False)

        # Init our targets
        logger.warn("Init targets")
        avatar.init_targets()
        set_record_hooks(avatar, args)

        # Is a Python module going to stimulate the firmware?
        # I.e., instead of human input
        simulator_proccess = None
        if args.stimulator:
            logger.info("Starting a stimulator...")
            # Load the stimulator out of the library
            Stimulator = getattr(
                importlib.import_module("pretender.stimulators"),
                args.stimulator)
            simulator_proccess = Stimulator()
            simulator_proccess.start()
            simulator_proccess.wait_for_connection()

        # Are we recording interrupts?
        if args.interrupts:
            l.info("Loading interrupt plugins...")
            avatar.load_plugin('arm.armv7m_interrupts')
            avatar.load_plugin('instruction_forwarder')
            avatar.load_plugin('assembler')
            avatar.load_plugin('disassembler')

            # NOTE: On the nordic, we can't write the stub in unless we twiddle some bits first!
            # hardware.write_memory(0x4001e504, 4, 2) # Get ready to get violent
            # hardware.write_memory(0x4001e508, 4, 0)
            # hardware.write_memory(0x4001e508, 4, 1) # Blow the IVT to smitherines
            # hardware.write_memory(0x4001e504, 4, 1) # Get ready to write a new one
            # hardware.write_memory(0x0, 4, 0x20001000)
            # for x in range(0, 64):
            #    hardware.write_memory(x, 4, 0x2000124d)
            logger.info("Injecting the magic interrupt stub")
            avatar.enable_interrupts(hardware, qemu)
            logger.warning("Starting the target in the stub")
            # # ## TODO: FIXME: HACK: This is a hack.  It's catchy.  You like it.
            # hardware.remove_breakpoint(0)
            # hardware.remove_breakpoint(1)
            # hardware.remove_breakpoint(2)
            hardware.set_breakpoint(hardware.protocols.interrupts.get_isr(20))
            # hardware.set_breakpoint(hardware.protocols.interrupts.get_isr(20))
            hardware.cont()

            if "ignore_irqs" in args:
                for irq_num in args.ignore_irqs:
                    logger.info("Ignoring interrupt #%d" % irq_num)
                    qemu.protocols.interrupts.ignore_interrupt_return(irq_num)

            # Is there a fixed IVT? (e.g,. CM0)
            if args.ivt_address is not None:
                logger.warning(
                    "Setting QEMU interrupt table to %#08x" % args.ivt_address)
                qemu.protocols.interrupts.set_vector_table_base(
                    args.ivt_address)

        # TODO: Set VTOR?
        logger.info("Set EIP to %s and ESP to %s" % (hex(ep), hex(sp)))
        qemu.regs.pc = ep
        qemu.regs.sp = sp

        # Record our start time
        time_start = time.time()
        # Update our memory log
        memory_log = LogWriter(os.path.join(args.output_dir,
                                            "recording%d.%s" % (
                                                run, G.RECORDING_EXTENSION)))
        # Control loop
        if args.shell:
            # Just open a Python shell
            import IPython

            IPython.embed()
        else:
            # run the firmware for a specified period of time
            qemu.cont()
            logger.info("Running and recording for a bit")
            time.sleep(args.sleep_time)
            # qemu.wait()

            logger.info("All done. Stopping emulator")

        # Kill our stimulator
        if simulator_proccess:
            logger.info("Stopping stimulator")
            simulator_proccess.shutdown()

        # Stop executing our firmware
        qemu.stop()

        # Stop the loop on our hardware that waits for interrupts
        if args.interrupts:
            try:
                logger.info("Stopping target")
                hardware.stop()
            except:
                pass

        # Close everything up
        logger.info("Shutting down Avatar...")
        avatar.shutdown()
        logger.info("Done.")

        if G.COVERAGE_LOG:
            blocks = get_hit_blocks(G.COVERAGE_LOG)
            print "Hit blocks:", repr(blocks)
            print "Hit %d blocks" % len(blocks)

            f = open(os.path.join(args.output_dir, "coverage%d.txt" % run),
                     mode="w+")
            f.write("Hit blocks: %s" % repr(blocks))
            f.write("Hit %d blocks" % len(blocks))
            f.close()

    if memory_log:
        memory_log.close()

"""
Notes:
Manipulate LED
on: nucleo.write_memory(0x40020018, 2, 32)
off: nucleo.write_memory(0x40020028, 2, 32)
"""
