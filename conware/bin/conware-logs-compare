#!/usr/bin/env python
import itertools
import sys
import argparse
import csv
import logging
import pandas as pd

logger = logging.getLogger(__name__)
# emulated log: Operation Seqn	Address	Value	Value (Model)	PC	Size	Timestamp	Model /////////This is a tsv file
# recorded log: Operation	Seqn	Address	Value	Value (Model)	PC	Size	Timestamp	Model ///////// this is listed as a csv file but it is a tsv file

recorded_reads = []
recorded_reads_referecne = {}
recorded_writes = []
recorded_writes_reference = {}
emulated_reads = []
emulated_writes = []
count = 0


def main(emulated, recorded):
    emulated_log = file(emulated, 'r')
    recorded_log = file(recorded, 'r')

    emulated_csv = csv.reader(emulated_log, dialect=csv.excel_tab)
    recorded_csv = csv.reader(recorded_log, dialect=csv.excel_tab)

    recorded_tuples = []
    emulated_tuples = []

    # Read relevant tuples from recording
    for row in recorded_csv:
        recorded_tuples.append((row[0], row[2], row[3]))
        if row[0] == 'READ':
            recorded_reads.append([row[2], row[3], row[6]])
        elif row[0] == 'WRITE':
            recorded_writes.append([row[2], row[3], row[6]])

    # Read relevant tuples from emulated output
    for row in emulated_csv:
        emulated_tuples.append((row[0], row[2], row[3]))
        if row[0] == 'READ':
            emulated_reads.append([row[2], row[3], row[6]])
        elif row[0] == 'WRITE':
            emulated_writes.append([row[2], row[3], row[6]])

    idx_emulated = 0
    idx_recorded = 0

    not_equal_count = 0
    repeat_count = 0

    while idx_recorded < len(recorded_tuples) and idx_emulated < len(
            emulated_tuples):
        op_emu, addr_emu, value_emu = emulated_tuples[idx_emulated]

        op_rec, addr_rec, value_rec = recorded_tuples[idx_recorded]
        if op_rec == op_emu and addr_rec == addr_emu:
            if value_emu != value_rec:
                # Let's check to see if we have any duplicate values (e.g.,
                # status registers)

                # Check to see if emulated keeps repeating
                idx_tmp = idx_emulated
                while idx_tmp < len(emulated_tuples) and emulated_tuples[
                    idx_tmp] == (op_emu, addr_emu, value_emu):
                    idx_tmp += 1
                if idx_tmp == len(emulated_tuples):
                    logger.info(
                        "Hit end of emulated log (%d early)" % (idx_tmp -
                                                                idx_emulated))
                    break
                # Looks like we just had a long repeat
                if recorded_tuples[idx_recorded] == emulated_tuples[idx_tmp]:
                    logger.debug("Skipped %d lines in emulated output." %
                                 (idx_tmp - idx_emulated))
                    repeat_count += idx_tmp - idx_emulated
                    idx_emulated = idx_tmp
                    continue

                # Check to see if the recording keeps repeating
                idx_tmp = idx_recorded
                while idx_tmp < len(recorded_tuples) and recorded_tuples[
                    idx_tmp] == (op_rec, addr_rec, value_rec):
                    idx_tmp += 1
                # Looks like we just had a few repeats
                if idx_tmp == len(recorded_tuples):
                    logger.info(
                        "Hit end of recorded log (%d early)" % (idx_tmp -
                                                                idx_recorded))
                    break
                if recorded_tuples[idx_recorded] == emulated_tuples[idx_tmp]:
                    logger.debug("Skipped %d lines in recorded output." %
                                 (idx_tmp - idx_recorded))
                    repeat_count += idx_tmp - idx_recorded
                    idx_recorded = idx_tmp
                    continue

                # Hum... they never synced up?
                not_equal_count += 1
                idx_emulated += 1
                idx_recorded += 1
                logger.warning("Found unequal rows %s != %s" % (
                    recorded_tuples[idx_recorded],
                    emulated_tuples[idx_emulated]))
            else:
                # Equal!
                idx_emulated += 1
                idx_recorded += 1
                continue
        else:
            # Let's advance until they sync up again
            next_emu = idx_emulated
            next_rec = idx_recorded

            # Find the next index in each that makes them both equal
            while next_emu < len(emulated_tuples) and \
                    emulated_tuples[next_emu] != recorded_tuples[idx_recorded]:
                next_emu += 1

            while next_rec < len(recorded_tuples) and \
                    recorded_tuples[next_rec] != emulated_tuples[idx_emulated]:
                next_rec += 1

            # Increment the smallest jump in the sequence
            if (next_rec - idx_recorded) < (next_emu - idx_emulated):
                logger.warning("%d lines missing from emulated @ %d." % (
                    next_rec - idx_recorded, idx_emulated))

                not_equal_count += next_rec - idx_recorded
                while idx_recorded < next_rec:
                    print("%d: %s %s %s" % ((idx_recorded + 1,
                                             ) + recorded_tuples[idx_recorded]))
                    idx_recorded += 1
                continue
            else:
                logger.warning("%d lines missing from recording. @ %d" % (
                    next_emu - idx_emulated, idx_recorded))
                not_equal_count = next_emu - idx_emulated
                while idx_emulated < next_emu:
                    print("%d: %s %s %s" % (
                            (idx_emulated + 1,) + emulated_tuples[
                        idx_emulated]))
                    idx_emulated += 1
                continue

        logger.error("Pretty sure this should never happen...")
        not_equal_count += 1
        idx_emulated += 1
        idx_recorded += 1
        continue


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument('emulated_log')
    parser.add_argument('recorded_log')

    args = parser.parse_args()

    logging.basicConfig(level=logging.INFO)
    main(args.emulated_log, args.recorded_log)
